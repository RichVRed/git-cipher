#!/usr/bin/env ruby
# git-cipher -- encrypt/decrypt files
#
# Utility script for encrypting sensitive files suitable for storage in a public
# Git repo. For more details on why we need this, see bin/decrypt.
#
# Note you need to set the key trust level on your signing key to "ultimate" to
# avoid prompts like:
#
#     It is NOT certain that the key belongs to the person named
#     in the user ID.  If you *really* know what you are doing,
#     you may answer the next question with yes.
#
# You can do that with:
#
#     gpg --edit-key greg@hurrell.net
#     > trust
#     > quit

require 'fileutils' # for FileUtils.uptodate?
require 'pathname'
require 'shellwords'

GPG_USER  = ENV['GPG_USER'] || 'greg@hurrell.net'
EXTENSION = 'encrypted'

def strip_heredoc(doc)
  # based on method of same name from Rails
  indent = doc.scan(/^[ \t]*(?=\S)/).map(&:size).min || 0
  doc.gsub(/^[ \t]{#{indent}}/, '')
end

def check_ignored(path)
  `git check-ignore -q #{Shellwords.escape path}`
  puts "[warning: #{path} is not ignored]" unless $?.exitstatus.zero?
end

def die(msg)
  STDERR.puts 'error:', strip_heredoc(msg)
  exit 1
end

def red(string)
  colorize(string, 31)
end

def green(string)
  colorize(string, 32)
end

def blue(string)
  colorize(string, 34)
end

def kill_line()
  # 2K deletes the line, 0G moves to column 0
  # see: http://en.wikipedia.org/wiki/ANSI_escape_code
  "\e[2K\e[0G"
end

def colorize(string, color)
  "\e[#{color}m#{string}\e[0m"
end

$force = ARGV.delete('--force') || ARGV.delete('-f')

def command_name
  @command_name ||= begin
    if `ps -p #{Process.ppid.to_i}` =~ /\bgit cipher\b/
      'git cipher'
    else
      File.basename(__FILE__)
    end
  rescue
    File.basename(__FILE__)
  end
end

def usage
  puts strip_heredoc(<<-USAGE)
    # encrypt two files, but only if the corresponding ciphertext files are
    # missing or older
    #{command_name} encrypt foo bar

    # encrypt all encryptable files
    #{command_name} encrypt

    # (re-)encrypt all encryptable files, even those whose corresponding
    # ciphertext files are newer
    #{command_name} encrypt -f # also: #{command_name} encrypt --force

    # show help
    #{command_name} encrypt -h # also: #{command_name} encrypt --help
  USAGE
end

def process(file)
  unless file.exist?
    die "#{file} does not exist}"
  end

  outfile = file.dirname + ".#{file.basename}.#{EXTENSION}"

  print "#{file} -> #{outfile} "
  if FileUtils.uptodate?(outfile, [file]) && !$force
    puts blue('[up to date]')
  else
    print green('[encrypting ...')
    `gpg -a -q --batch --no-tty --yes -r #{GPG_USER} -o #{outfile} -e #{file}`
    if $?.success?
      puts green(' done]')
    else
      print kill_line()
      puts red('[encrypting ... failed; bailing]')
      exit $?.exitstatus
    end
  end

  File.chmod(0600, file)
  check_ignored(file)
end

if ARGV.include?('-h') || ARGV.include?('--help')
  usage
  exit
end

if ARGV.empty?
  puts 'No explicit paths supplied: encrypting all matching files'
  Dir["**/.*.#{EXTENSION}"].each do |file|
    file = Pathname.new(file)
    process(
      file.dirname +
      file.basename.to_s.gsub(/\A\.|\.#{EXTENSION}\z/, '')
    )
  end
else
  ARGV.each { |file| process(Pathname.new(file)) }
end
